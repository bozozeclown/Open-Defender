// src/utils/vulnerability_scanner.rs
use anyhow::{Context, Result};
use chrono::{DateTime, Duration, Utc};
use reqwest::Client;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use tokio::sync::RwLock;
use tracing::{debug, error, info, warn};

use crate::config::{CveManagerConfig, PatchManagerConfig, SoftwareInventoryConfig, VulnerabilityScannerConfig};

pub struct VulnerabilityManager {
    cve_manager: CveManager,
    software_inventory: SoftwareInventory,
    vulnerability_scanner: VulnerabilityScanner,
    patch_manager: PatchManager,
}

impl VulnerabilityManager {
    pub fn new(
        cve_config: CveManagerConfig,
        software_config: SoftwareInventoryConfig,
        scanner_config: VulnerabilityScannerConfig,
        patch_config: PatchManagerConfig,
    ) -> Result<Self> {
        Ok(Self {
            cve_manager: CveManager::new(cve_config)?,
            software_inventory: SoftwareInventory::new(software_config)?,
            vulnerability_scanner: VulnerabilityScanner::new(scanner_config)?,
            patch_manager: PatchManager::new(patch_config)?,
        })
    }

    pub async fn run(&mut self) -> Result<()> {
        let mut cve_interval = tokio::time::interval(
            tokio::time::Duration::from_secs(self.cve_manager.config.update_interval * 3600),
        );
        let mut software_interval = tokio::time::interval(
            tokio::time::Duration::from_secs(self.software_inventory.config.scan_interval * 3600),
        );
        let mut scanner_interval = tokio::time::interval(
            tokio::time::Duration::from_secs(self.vulnerability_scanner.config.scan_interval * 3600),
        );

        loop {
            tokio::select! {
                _ = cve_interval.tick() => {
                    if let Err(e) = self.cve_manager.update_cve_database().await {
                        error!("Failed to update CVE database: {}", e);
                    }
                }
                _ = software_interval.tick() => {
                    if let Err(e) = self.software_inventory.scan_software().await {
                        error!("Failed to scan software: {}", e);
                    }
                }
                _ = scanner_interval.tick() => {
                    if let Err(e) = self.vulnerability_scanner.scan_vulnerabilities().await {
                        error!("Failed to scan vulnerabilities: {}", e);
                    }
                }
            }
        }
    }
}

pub struct CveManager {
    config: CveManagerConfig,
    cve_database: RwLock<HashMap<String, CveEntry>>,
    client: Client,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CveEntry {
    pub id: String,
    pub description: String,
    pub cvss_score: f64,
    pub published_date: DateTime<Utc>,
    pub last_modified: DateTime<Utc>,
    pub references: Vec<String>,
}

impl CveManager {
    pub fn new(config: CveManagerConfig) -> Result<Self> {
        Ok(Self {
            config,
            cve_database: RwLock::new(HashMap::new()),
            client: Client::new(),
        })
    }

    pub async fn update_cve_database(&self) -> Result<()> {
        info!("Updating CVE database");

        let mut updated_count = 0;
        let cutoff_date = Utc::now() - Duration::days(self.config.max_cve_age as i64);

        for source in &self.config.sources {
            match source.as_str() {
                "nvd" => {
                    let count = self.update_from_nvd(&cutoff_date).await?;
                    updated_count += count;
                }
                "mitre" => {
                    let count = self.update_from_mitre(&cutoff_date).await?;
                    updated_count += count;
                }
                _ => warn!("Unknown CVE source: {}", source),
            }
        }

        info!("CVE database updated with {} new entries", updated_count);
        Ok(())
    }

    async fn update_from_nvd(&self, cutoff_date: &DateTime<Utc>) -> Result<usize> {
        // Implementation for NVD API integration
        // This would fetch CVEs from NVD API and update the database
        Ok(0)
    }

    async fn update_from_mitre(&self, cutoff_date: &DateTime<Utc>) -> Result<usize> {
        // Implementation for MITRE CVE integration
        // This would fetch CVEs from MITRE and update the database
        Ok(0)
    }

    pub async fn get_cve(&self, cve_id: &str) -> Option<CveEntry> {
        let db = self.cve_database.read().await;
        db.get(cve_id).cloned()
    }

    pub async fn get_high_severity_cves(&self) -> Vec<CveEntry> {
        let db = self.cve_database.read().await;
        db.values()
            .filter(|cve| cve.cvss_score >= self.config.cvss_threshold)
            .cloned()
            .collect()
    }
}

pub struct SoftwareInventory {
    config: SoftwareInventoryConfig,
    software_list: RwLock<HashMap<String, SoftwareEntry>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SoftwareEntry {
    pub name: String,
    pub version: String,
    pub vendor: String,
    pub install_date: DateTime<Utc>,
    pub path: String,
    pub is_system_component: bool,
}

impl SoftwareInventory {
    pub fn new(config: SoftwareInventoryConfig) -> Result<Self> {
        Ok(Self {
            config,
            software_list: RwLock::new(HashMap::new()),
        })
    }

    pub async fn scan_software(&self) -> Result<()> {
        info!("Scanning installed software");

        #[cfg(target_os = "windows")]
        {
            self.scan_windows_software().await?;
        }

        #[cfg(target_os = "linux")]
        {
            self.scan_linux_software().await?;
        }

        info!("Software scan completed");
        Ok(())
    }

    #[cfg(target_os = "windows")]
    async fn scan_windows_software(&self) -> Result<()> {
        use winreg::enums::*;
        use winreg::RegKey;

        let hklm = RegKey::predef(HKEY_LOCAL_MACHINE);
        
        // Scan 32-bit software
        let software_key = hklm.open_subkey_with_flags(
            r"SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall",
            KEY_READ,
        )?;
        
        for (name, _) in software_key.enum_keys().flatten() {
            if let Ok(app_key) = software_key.open_subkey(&name) {
                if let Ok(entry) = self.parse_windows_registry_entry(&app_key) {
                    if self.config.include_system_components || !entry.is_system_component {
                        let mut list = self.software_list.write().await;
                        list.insert(format!("{}:{}", entry.name, entry.version), entry);
                    }
                }
            }
        }

        // Scan 64-bit software
        let software_key64 = hklm.open_subkey_with_flags(
            r"SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall",
            KEY_READ,
        )?;
        
        for (name, _) in software_key64.enum_keys().flatten() {
            if let Ok(app_key) = software_key64.open_subkey(&name) {
                if let Ok(entry) = self.parse_windows_registry_entry(&app_key) {
                    if self.config.include_system_components || !entry.is_system_component {
                        let mut list = self.software_list.write().await;
                        list.insert(format!("{}:{}", entry.name, entry.version), entry);
                    }
                }
            }
        }

        Ok(())
    }

    #[cfg(target_os = "windows")]
    fn parse_windows_registry_entry(&self, key: &winreg::RegKey) -> Result<SoftwareEntry> {
        let name: String = key.get_value("DisplayName").unwrap_or_default();
        let version: String = key.get_value("DisplayVersion").unwrap_or_default();
        let publisher: String = key.get_value("Publisher").unwrap_or_default();
        let install_date_str: String = key.get_value("InstallDate").unwrap_or_default();
        
        let install_date = if install_date_str.len() == 8 {
            let year = install_date_str[0..4].parse::<i32>()?;
            let month = install_date_str[4..6].parse::<u32>()?;
            let day = install_date_str[6..8].parse::<u32>()?;
            Utc.ymd(year, month, day).and_hms(0, 0, 0)
        } else {
            Utc::now()
        };
        
        let install_location: String = key.get_value("InstallLocation").unwrap_or_default();
        let system_component: u32 = key.get_value("SystemComponent").unwrap_or(0);
        
        Ok(SoftwareEntry {
            name,
            version,
            vendor: publisher,
            install_date,
            path: install_location,
            is_system_component: system_component == 1,
        })
    }

    #[cfg(target_os = "linux")]
    async fn scan_linux_software(&self) -> Result<()> {
        // Implementation for Linux software scanning
        // This would use package manager APIs (dpkg, rpm, etc.)
        Ok(())
    }

    pub async fn get_software(&self) -> Vec<SoftwareEntry> {
        let list = self.software_list.read().await;
        list.values().cloned().collect()
    }
}

pub struct VulnerabilityScanner {
    config: VulnerabilityScannerConfig,
    client: Client,
}

impl VulnerabilityScanner {
    pub fn new(config: VulnerabilityScannerConfig) -> Result<Self> {
        Ok(Self {
            config,
            client: Client::new(),
        })
    }

    pub async fn scan_vulnerabilities(&self) -> Result<Vec<Vulnerability>> {
        info!("Scanning for vulnerabilities");

        // Get software inventory
        let software = SoftwareInventory::new(SoftwareInventoryConfig {
            scan_interval: 0,
            include_system_components: false,
        })?;
        software.scan_software().await?;
        let software_list = software.get_software().await;

        // Get CVE database
        let cve_manager = CveManager::new(CveManagerConfig {
            update_interval: 0,
            sources: vec!["nvd".to_string()],
            max_cve_age: 365,
            cvss_threshold: 0.0,
        })?;
        let cve_list = cve_manager.get_high_severity_cves().await;

        // Match software with CVEs
        let mut vulnerabilities = Vec::new();
        
        for software in software_list {
            for cve in &cve_list {
                if self.is_software_vulnerable(&software, cve) {
                    vulnerabilities.push(Vulnerability {
                        id: uuid::Uuid::new_v4().to_string(),
                        software_name: software.name.clone(),
                        software_version: software.version.clone(),
                        cve_id: cve.id.clone(),
                        severity: self.calculate_severity(cve.cvss_score),
                        description: cve.description.clone(),
                        detected_at: Utc::now(),
                    });
                }
            }
        }

        info!("Found {} vulnerabilities", vulnerabilities.len());

        // Auto-remediate if enabled
        if self.config.auto_remediate {
            self.auto_remediate(&vulnerabilities).await?;
        }

        Ok(vulnerabilities)
    }

    fn is_software_vulnerable(&self, software: &SoftwareEntry, cve: &CveEntry) -> bool {
        // Simplified vulnerability matching
        // In a real implementation, this would use more sophisticated matching
        cve.description.to_lowercase().contains(&software.name.to_lowercase())
    }

    fn calculate_severity(&self, cvss_score: f64) -> String {
        match cvss_score {
            score if score >= 9.0 => "Critical".to_string(),
            score if score >= 7.0 => "High".to_string(),
            score if score >= 4.0 => "Medium".to_string(),
            score if score > 0.0 => "Low".to_string(),
            _ => "Info".to_string(),
        }
    }

    async fn auto_remediate(&self, vulnerabilities: &[Vulnerability]) -> Result<()> {
        info!("Auto-remediating {} vulnerabilities", vulnerabilities.len());

        for vuln in vulnerabilities {
            if vuln.severity == self.config.notification_threshold {
                // Attempt to patch the vulnerability
                info!("Auto-remediating vulnerability: {}", vuln.id);
                // Implementation would go here
            }
        }

        Ok(())
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vulnerability {
    pub id: String,
    pub software_name: String,
    pub software_version: String,
    pub cve_id: String,
    pub severity: String,
    pub description: String,
    pub detected_at: DateTime<Utc>,
}

pub struct PatchManager {
    config: PatchManagerConfig,
    client: Client,
}

impl PatchManager {
    pub fn new(config: PatchManagerConfig) -> Result<Self> {
        Ok(Self {
            config,
            client: Client::new(),
        })
    }

    pub async fn check_for_patches(&self) -> Result<Vec<Patch>> {
        info!("Checking for available patches");

        // Implementation would check for available patches
        // This would integrate with OS update mechanisms or vendor APIs
        Ok(vec![])
    }

    pub async fn download_patches(&self, patches: &[Patch]) -> Result<()> {
        info!("Downloading {} patches", patches.len());

        for patch in patches {
            info!("Downloading patch: {}", patch.id);
            // Implementation would download patches
        }

        Ok(())
    }

    pub async fn deploy_patches(&self, patches: &[Patch]) -> Result<()> {
        info!("Deploying {} patches", patches.len());

        // Check if we're in the deployment window
        if self.is_in_deployment_window() {
            for patch in patches {
                info!("Deploying patch: {}", patch.id);
                // Implementation would deploy patches
            }
        } else {
            info!("Not in deployment window, scheduling patches for later");
        }

        Ok(())
    }

    fn is_in_deployment_window(&self) -> bool {
        // Parse deployment window (e.g., "02:00-04:00")
        let parts: Vec<&str> = self.config.deployment_window.split('-').collect();
        if parts.len() != 2 {
            return false;
        }

        let now = Utc::now().time();
        let start_time = parts[0].parse::<chrono::NaiveTime>().ok()?;
        let end_time = parts[1].parse::<chrono::NaiveTime>().ok()?;

        now >= start_time && now <= end_time
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Patch {
    pub id: String,
    pub software_name: String,
    pub version: String,
    pub description: String,
    pub size_bytes: u64,
    pub download_url: String,
    pub release_date: DateTime<Utc>,
}
